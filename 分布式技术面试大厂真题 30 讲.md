# 分布式技术面试大厂真题 30 讲

### 分布式基础篇

* 谈谈你对分布式的理解，为什么引入分布式？

  * 面试官：谈谈你对分布式系统的理解

    什么是分布式系统：

    为了解决传统单体服务架构带来的各种问题，代码数量庞大，迭代测试维护困难，可能因为一处改动测试不到位造成整个服务瘫痪等问题，分布式系统就是将一个大的服务拆分成几十个甚至上百个微小的服务。如果把单体架构服务器比做篮子，那代码就是鸡蛋，不要让所有鸡蛋装在一个篮子里，也方便大家分工开发，代码不在一个项目里，也不会冲突。

    比如 Dubbo、Spring Cloud，都是解决分布式微服务架构的优秀框架。

  * 面试官：分布式系统环境下各自有什么优缺点？

    优点：

    **系统可用性提升**，一个系统全年可用时间在 99.999%，5 个 9 的服务可用率在设计合理的分布式系统中并不是一个触不可及的数字。

    **系统并发能力提升**，请求通过 Nginx 负载均衡被分发到不同的服务器上，运行同样代码的服务器可以有 1 台或 N 台，通常情况下会根据实际用户访问量随时增加机器，无论是数据库或者服务，都可以做到随时水平扩展。

    **系统容错能力提升**，同一组服务分别部署在北京上海杭州，杭州的机房突发断电或者火灾，杭州机房的流量会被自动分发到北京和上海的机房，不影响用户使用。

    **低延迟**，北京的用户请求自动分发到北京，上海的用户请求被分发到上海，服务器会根据用户的 IP 选择距离自己最近的机房，降低网络延迟。

    缺点：

    **分布式服务依赖网络**，服务器间通讯依赖网络，不可靠网络包括网络延时，丢包、中断、异步，一个完整的服务请求依赖一连串服务调用，任意一个服务节点网络出现问题，都可能造成本次请求失败。

    **维护成本高**，传统单体式服务只需要维护一个站点就可以。分布式服务系统被拆分成若干个小服务，服务从 1 变为几十个上百个服务后，增加运维成本。

    **一致性，可用性，分区容错性无法同时满足**，这三种特性就是平时说的 CAP 定理，在分布式系统中，这三种特性最多只能满足两种，无法同时满足，需要根据实际情况去调整牺牲掉其中哪个。

    深入分析：

    关于分布式系统，通俗点讲就把整个业务系统拆分成很多的服务，每个服务责任到人，服务之间代码都没有冲突，服务可以自治，每个服务的技术也可以自己选型，只要遵循统一的服务调用协议就可以了。每次发布如果只改动一个服务那就上线一个服务，不用所有人一起联调，这样每次发布牵扯到的改动影响也是可控的。不像传统单体架构服务，动辄几百万行代码融在一起。

    分布式系统并不是某一门具体的技术，也不是具体的框架。用大白话理解就是将计算能力和数据存储能力分散在不同服务器上，通过网络连接组成的一个整体的服务，不同服务器可能是物理机，也可能是虚拟机，分布式的概念可以理解成一种解决方案。

    分布式系统总结来说是将数据存储能力和计算能力分布到不同的服务器上，作为一个整体对外服务。目的在于解决单台机器的故障问题，单机计算和 IO 性能问题，以及单机存储空间不足的问题。虽然单机故障的概率比较小，但是随着集群规模大了之后，集群宕机和磁盘损坏基本上是常态，分布式系统主要解决的是各种故障带来的问题。

  * 分布式系统和微服务什么关系

    关于分布式系统和微服务，两者都只是一种概念。如果你采用微服务，就意味着系统一定是分布式的，分布式系统具有的优缺点在微服务里都会体现，个人理解微服务是分布式系统的一种具体落地方案。
    
  * 分布式系统一定是集群的吗？

    还要先理解两者的概念。其实分布式不一定就是不同的组件，同一个组件也可以，关键在于是否通过交换信息的方式进行协作。比如说 Zookeeper 的节点都是对等的，但它自己就构成一个分布式系统。也就是说，分布式是指通过网络连接的多个组件，通过交换信息协作而形成的系统。而集群，是指同一种组件的多个实例，形成的逻辑上的整体。可以看出这两个概念并不完全冲突，分布式系统也可以是一个集群，例子就是前面说的 Zookeeper 等，它的特征是服务之间会互相通信协作。是分布式系统不是集群的情况，就是多个不同组件构成的系统；是集群不是分布式系统的情况，比如多个经过负载均衡的 HTTP 服务器，它们之间不会互相通信，如果不带上负载均衡的部分的话，一般不叫做分布式系统。 

* 公司使用什么 RPC 框架，聊聊你理解的 RPC 原理

  * 面试官：公司使用什么 RPC 框架？可以介绍一下 RPC 的工作原理吗？

    RPC 是一个分布式计算的 CS 模式，总是由 Client 向 Server 发出一个执行若干过程请求，Server 接受请求，使用客户端提供的参数，计算完成之后将结果返回给客户端。

    ![RPC 原理](https://github.com/songor/interview/blob/master/picture/RPC%20%E5%8E%9F%E7%90%86.jpg)

    服务集成 RPC 后，服务（这里的服务就是图中的 Provider，服务提供者）启动后会通过 Register（注册）模块，把服务的唯一 ID、IP 地址、端口信息等注册到 RPC 框架注册中心（图中的 Registry 部分）。

    当调用者（Consumer）想要调用服务的时候，通过 Provider 注册时的的服务唯一 ID 去注册中心查找在线可供调用的服务，返回一个 IP 列表（3.notify 部分）。

    Consumer 根据一定的策略，比如随机或轮询从 Registry 返回的可用 IP 列表中选择真正调用的服务（4.invoke）。

    RPC 框架都提供监控功能，监控服务健康状况，控制服务线上扩展和上下线（5.count）

  * 面试官：服务启动的时候服务基本信息被注册到注册中心，如果服务提供者挂了，注册中心如何知道服务不可用了呢？

    服务掉线分为主动下线和心跳检测。

    比如服务发新版本时，在重启之前主动通知注册中心，我要重启了，有流量进来不要分发给我，等我重启成功后再放流量进来，或者在管理后台手动摘掉机器，这个是主动下线。

    心跳检测是处理服务非正常下线（如断电断网）的情况。注册中心增加一个心跳检测功能，它会对服务提供者（Provider）进行心跳检测，比如每隔 30s 发送一个心跳，如果三次心跳结果都没有返回值，就认为该服务已下线，赶紧更新 Consumer 的服务列表，告诉 Consumer 调用别的机器。

  * 面试官：如果注册中心挂了，比如你用的是 Zookeeper，如果 Zookeeper 挂了，那服务之间还能相互调用吗？

    首先注册中心挂掉也要分两种情况，如果数据库挂了，ZK 还是能用的，因为 ZK 会缓存服务列表。

    其次 ZK 本身就是一个集群，一台机器挂了，ZK 会选举出集群中的其他机器作为 Master 继续提供服务，如果整个集群都挂了也没问题，因为调用者本地会缓存从注册中心获取的服务列表，省略和注册中心的交互，Consumer 和 Provider 采用直连方式，这些策略都是可配置的。

  * 面试官：能否自己写一个 RPC 框架？

    ![RPC 框架](https://github.com/songor/interview/blob/master/picture/RPC%20%E6%A1%86%E6%9E%B6.jpg)

    客户端 invoke 方法编写，使用 JDK 的动态代理技术，客户端调用远程服务方法时调用的是 InvocationHandler 的 invoke 方法。

    客户端 Filter 方法编写，完善的 RPC 框架少不了监控、路由、降级、鉴权等功能。创建 Socket，在 Filter 方法中实现 Client.write 方法，其逻辑为从连接池（Channel Pool）中获取连接，然后将数据写进 Channel。

    实现数据序列化、压缩，目的是减少网络传输的数据量，向服务端发送 request 数据，这里可以使用 Netty 异步通讯框架。

    服务端收到客户端发来的消息后，从 Channel 中将消息读出来之前，也会先经反序列化解压，请求就到了服务端 Filter 中，请求依次经过监控、鉴权方法。

    根据客户端传递来的服务信息和参数，通过反射调用相应的业务服务并拿到业务处理结果，然后在 ResponseFilter 中将返回结果写入 Channel。

    服务端序列化、压缩等，发送给客户端。

    客户端收到消息后，经过客户端反序列化、解压缩后交给 ResponseThreadPoolProcessor 线程池处理。ResponseThreadPoolProcessor 收到消息后，就将结果返回给之前的方法调用，整个调用请求就结束了。

  * 已经有 HTTP 协议接口，或者说 RESTful 接口，为什么还要使用 RPC 技术？

    在接⼝不多的情况下，使用 HTTP 确实是一个明智的选择，开发简单、测试也比较直接、部署方便，利用现成的 HTTP 协议进行系统间通讯。

    如果业务慢慢做大，系统也慢慢扩大，RPC 框架的好处就显示出来了：

    ⾸先 RPC 支持长链接，通信不必像 HTTP 一样每次去重复 3 次握⼿，减少了网络开销。

    其次 RPC 框架一般都有注册中心模块，有完善的监控管理功能，服务注册发现、服务下线、服务动态扩展等，服务化治理效率大大提高。

    基于 TCP 协议实现的 RPC，能更灵活地对协议字段进行定制，相比 HTTP 能减少网络传输字节数，降低网络开销（握手），提高性能，实现更大的吞吐量和并发数，但是需要更多地关注底层复杂细节， 对开发人员的要求也较高，增加开发成本。

* 详细说下 CAP 分别代表什么含义

  * 面试官：说到 CAP 定理，能详细说说 CAP 分别代表什么吗？

    Consistency - 一致性，Availability - 可用性，Partition tolerance - 分区容错性。

    一个分布式系统最多同时满足一致性，可用性和分区容错性这三项中的两项。

    深入分析：

    用 Redis Cluster 高可用架构举例，Redis 会将数据分片到多个实例（按照 slot 存储）中，即一个机房分担一部分数据。Master 负责写，Master 会自动同步到 Slave。

    ![Redis Cluster](https://github.com/songor/interview/blob/master/picture/Redis%20Cluster.jpg)

    无中心架构，三机房部署，其中一主一从构成一个分片，之间通过异步复制同步数据，异步复制存在数据不一致的时间窗口，保证可用性的同时牺牲了部分一致性。一旦某个机房掉线，则分片上位于另一个机房的 slave 会被提升为 master 从而可以继续提供服务。

    可扩展性，可线性扩展到 1000 多个节点，节点可动态添加或删除。

    消息的延迟会带来数据不一致问题，理想情况下消息不丢失那数据会最终一致。“最终一致性”，就是说不管消息延迟多久甚至丢失，设计一个离线定时任务，定期去扫描两个系统的数据，有不一致的情况就主动刷新同步，这样保证最终一致。

* 说一说什么是正向代理，反向代理

  * 面试官：使用 Nginx 做代理，你是如何理解正向代理，反向代理的？

    正向代理，代理用户端请求服务端，相对于服务器用户端是匿名的。比如单位内网使用了正向代理软件，所有员工都访问百度，但是百度看到的只有一个 IP 地址，百度也不知道到底是哪个员工访问的。

    反向代理，代理服务端提供服务，相对于用户服务端是匿名的。同样是访问百度，所有用户输入的都是一个域名或者一个 IP，但是百度背后有成千上万的服务器，你也不知道你访问的是哪一个。

  * 面试官：服务端为什么要使用代理？有啥好处？

    让 IO 和服务器分离，突破 IO 性能，提高服务器吞吐能力；

    控制流量分发，管理服务集群，起到负载均衡作用；

    安全性和匿名性，通过拦截前端服务器的请求，反向代理服务器可以保护其身份，并可以抵御安全攻击。它还确保可以从单个记录定位器或 URL 访问多个服务器，而不管服务端网络的结构如何。

  * 面试官：你知道哪些负载均衡算法？

    轮询算法：将多个用户请求按顺序依次分发到机器上，目的就是让每台机器承受相同的压力。

    加权轮询算法：设置不同机器的权重不同，10 台同配置机器分别均摊 10% 的流量，如果机器性能不同，让低配的机器权重降低，只承担 5% 的流量。

    随机算法：让所有请求随机分配到不同的机器上，请求越多最后分散在每台机器上的请求数约接近相等。

    加权随机算法：和加权轮询算法道理相似。

    最小连接数算法：请求分发之前，查看当前机器谁最清闲，谁当前处理的连接数最少，那就把活分给谁，最后的分工也相对公平。

    Hash 算法：前 5 种算法有一个问题，同一个用户的请求多次，可能每次都会被分配到不同的机器上，如果服务器缓存了用户 Session，那每次请求不同服务器都需要保存用户的 Session，最坏的结果就是每台服务器都缓存了同一个用户的 Session，这显然浪费了服务器资源。hash(client:ip) % N，N 就是服务器的数量，只要用户的 IP不变，最后 Hash 取余的结果就不会变，保证同一个用户每次请求都会在同一台机器上，这里的 IP 还可以是用户的其他唯一 ID。

    一致性 Hash 算法：hash(client:ip) % N，如果 N 变了怎么办？所有用户被分配到哪台机器需要全部重新计算，这对有 Session 状态的服务就是一场灾难。一致性 Hash 算法也是使用取模的方法，只是，刚才描述的取模法是对服务器的数量进行取模，而一致性 Hash 算法是对 2^32 取模，简单来说，一致性 Hash 算法将整个哈希值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织，圆环的正上方的点代表 0，0 点右侧的第一个点代表 1，以此类推，2、3、4、5、6 ... 直到 2^32-1，也就是说 0 点左侧的第一个点代表 2^32-1，0 和 2^32-1 在零点中方向重合，我们把这个由 2^32 个点组成的圆环称为 Hash 环。将各个服务器进行哈希，具体可以选择服务器的 IP 或主机名作为关键字，这样每台机器就能确定其在哈希环上的位置。数据 key 使用相同的 hash 函数计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。一般的，在一致性 Hash 算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。一般的，在一致性 Hash 算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。

  * 深入分析

    * 什么是负载均衡

      简单地理解负载均衡的作用就是流量分发，将大量用户请求分发到不同服务器上分担压力，如果有机器宕机，负载均衡服务器会负责把故障机器自动摘除。

    * 常用的负载均衡框架

      Nginx，LVS，HAProxy，F5

### Redis 缓存篇

* Redis 中有哪些数据结构及底层实现原理

  * Redis 有什么优势吗？

    Redis 支持丰富的数据结构；

    Redis 是读写单进程单线程，不用考虑并发读写的复杂场景，速度也快；

    Redis 功能完备，支持数据持久化，支持主从复制和集群；

    还有 Lua 脚本，事务，发布订阅模型，Redis 都支持。

    通过将数据存储到离 CPU 更近的位置，减少数据传输时间，提高处理效率，这就是缓存的意义。

  * 为什么单线程模型的 Redis 性能不减

    单线程不代表一定就慢，单线程模型避免了多线程的频繁上下文切换，这也避免了多线程可能产生的竞争问题；

    Redis 是基于内存的读写操作；

    Redis 核心是基于非阻塞的 IO 多路复用机制。

  * Redis 数据结构有哪几种

    字符串 String：字符串是 Redis 中最为基础的数据存储类型，数据结构简单，可存储文本、Json、图片数据等任何二进制文件。

    列表 List：类似 Java 中的 List，按照插入顺序排序的字符串链表，在插入时，如果该键不存在，Redis 将为该键创建一个新的链表。如果链表中所有的元素均被移除，那么该键也将会从数据库中删除。

    集合 Set：类似 Java 中的 Set，它是一个无序集合，用于存储无序（存入和取出的顺序不一定相同）元素，值不能重复。可以使用 Redis 的 Set 数据类型跟踪一些唯一性数据。

    有序集合 Sorted Set：类似 Java 中的 TreeSet，支持从小到大排序的 Set，适用于排行榜结构的数据存储。

    Hash：类似于 Java 中的 HashMap，该类型非常适合于存储对象。

  * 深入分析

    * Redis 字符串的实现方式

      简单动态字符串（simple dynamic string）简称 SDS。Redis 使用 C 语言编写，但是传统的 C 字符串使用长度为 N+1 的字符串数组来表示长度为 N 的字符串，所以为了获取一个字符串的长度，必须遍历整个字符串。在动态字符串的数据结构中，有专门用于保存字符串长度的变量，我们可以通过获取 len 属性的值，直接知道字符串长度，从一定程度上提高了读取效率。

      ```c
      struct sdshdr {
          int len;
          int free;
          char buf[];
      };
      ```

    * List 底层结构

      链表数据结构。链表是常规的普通双端链表，可以支持反向查找和遍历，通过增删节点来灵活地调整链表的长度。

    * Sorted Set 底层结构

      Sorted Set 内部使用字典（HashMap）和跳跃表（SkipList）来保证数据的存储和有序，HashMap 里放的是成员到 score 的映射，而跳跃表里存放的是所有的成员，排序依据 HashMap 里存的 score，使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。

      如果我们只使用字典来实现有序集合，那么虽然以 O(1) 复杂度查找成员的分值这一特性会被保留，但是，因为字典以无序的方式来保存集合元素，所以每次在执行范围型操作 ZRANK 、ZRANGE 等命令时，程序都需要对字典保存的所有元素进行排序，完成这种排序需要至少 O(N \ log N) 时间复杂度，以及额外的 O(N) 内存空间（因为要创建一个数组来保存排序后的元素）。

      如果我们只使用跳跃表来实现有序集合，那么跳跃表执行范围型操作的所有优点都会被保留，但因为没有了字典，所以根据成员查找分值这一操作的复杂度将从 O(1) 上升为 O(log N) 。

      为了让有序集合的查找和范围型操作都尽可能快地执行，Redis 选择了同时使用字典和跳跃表两种数据结构来实现有序集合。

      跳跃表其实可以把它理解为多层的链表，它有如下的性质：

      多层的结构组成，每层是一个有序的链表；

      最底层的链表包含所有的元素；

      跳跃表的查找次数近似于层数，时间复杂度为 O(log N)，插入、删除也为 O(log N)；

      跳跃表是一种随机化的数据结构（通过抛硬币来决定层数）。

      ![跳跃表](https://github.com/songor/interview/blob/master/picture/%E8%B7%B3%E8%B7%83%E8%A1%A8.jpg)

    * 关于缓存的一些算法

      缓存数据淘汰策略：

      FIFO（First In First Out），先进先出算法，即先放入缓存的先被移除。

      LRU（Least Recently Used），最近最少使用算法，使用时间距离现在最久的被移除。

      LFU（Least Frequently Used），最不常用算法，一定时间段内使用次数（频率）最少的被移除。

      缓存数据更新策略：

      定时任务从数据库直接更新缓存，适用于对时间不敏感的数据。

      查询时写缓存，即查询优先查询缓存，若缓存未命中，查询数据库，将返回结果写入缓存。

      MQ 消息异步更新缓存。

* Redis 持久化，高可用集群

  * 面试官：关于 Redis 持久化方式能说说吗？有哪两种？

    **RDB（Redis DataBase）：**

    RDB 是 Redis 默认的持久化方案。在指定的时间间隔内，执行指定次数的写操作，则会将内存中的数据写入到磁盘中，即在指定目录下生成一个 dump.rdb 文件。Redis 重启会通过加载 dump.rdb 文件恢复数据。

    Redis 提供了 SAVE 和 BGSAVE 两个命令来生成 RDB 文件，区别是前者是阻塞的，后者是后台 fork 子进程进行，不会阻塞主进程处理命令请求。载入 RDB 文件不需要手工运行，而是 server 端自动进行，只要启动时检测到 RDB 文件存在 server 端便会载入 RDB 文件重建数据集。

    优点：

    适合大规模的数据恢复，如果业务对数据完整性和一致性要求不高，RDB 的启动速度更快；

    RDB 文件简洁，它保存了某个时间点的 Redis 数据集，适合用于做备份。你可以设定一个时间点对 RDB 文件进行归档，如果 1s 间隔保存一次快照，这样就能在需要的时候很轻易地把数据恢复到不同的版本；

    考虑到磁盘硬件故障问题，RDB 文件很适合用于灾备，因为单文件可以很方便地传输到另外的数据中心；

    RDB 的性能很好，需要进行持久化时，主进程会 fork 一个子进程出来，然后把持久化的工作交给子进程，自己不会有相关的 I/O 操作。

    缺点：

    数据的完整性和一致性不高，因为 SAVE 命令执行是有时间间隔的；

    备份时占用内存，因为 Redis 在备份时会创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍），最后再将临时文件替换之前的备份文件。

    **AOF（Append Only File）：**

    Redis 默认不开启。它的出现是为了弥补 RDB 的不足（RDB 可能丢失一个时间窗口的数据），所以它采用日志的形式来记录每个写操作，生成一个 appendonly.aof 文件，并将日志追加到文件末尾。Redis 重启时会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作，有点类似 MySQL 的 binlog。

    优点：

    AOF 策略最大限度地保证数据不丢失，数据的完整性和一致性更高。

    缺点：

    AOF 备份产生的 appendonly.aof 文件较大，数据恢复的时候也会比较慢，Redis 针对 AOF 文件大的问题提供重写的瘦身机制。

  * 面试官：关于 Redis 集群的设计，你了解如何搭建一个高可用集群吗？

    Redis Cluster 集群模式：Master Slave 模式中，Master 成为集群中至关重要的一个节点，Master 的稳定性决定整个系统的稳定性，为解决这一问题，Redis Cluster 应需求而生，Redis Cluster 是官方在 Redis 3.0 版本正式推出的高可用以及分布式的解决方案，内置数据自动分片机制，由多个 Redis 实例组成的整体，数据按照槽（slot）存储分布在多个 Redis 实例上，集群内部将所有的 key 映射到 16384 个 Slot 中。

    实现的功能：

    将数据分片到多个实例（按照 slot 存储）；

    集群节点宕掉会自动 failover；

    提供相对平滑扩容（缩容）节点。

* 