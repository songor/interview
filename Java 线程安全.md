# Java 线程安全

### 不是线程的安全

线程安全不是指线程的安全，而是指内存的安全。

目前主流操作系统都是多任务的，即多个进程同时运行。为了保证安全，每个进程只能访问分配给自己的内存空间，而不能访问别的进程的，这是由操作系统保障的。

在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以访问到该区域，这就是造成问题的潜在原因。

所以线程安全指的是，**在堆内存中的数据由于可以被任何线程访问到，在没有任何限制的情况下存在被意外修改的风险**。

### 私有的东西就不该让别人知道（栈内存）

操作系统会为每个线程分配属于它自己的内存空间，通常称为栈内存，其它线程无权访问。这也是由操作系统保障的。

如果一些数据只有某个线程会使用，其他线程不能操作也不需要操作，这些数据就可以放入线程的栈内存中。较为常见的就是局部变量，局部变量会在每个线程的栈内存中都分配一份。

### 大家不要抢，人人有份（ThreadLocal）

现实中往往会有一个变量需要多个方法都能够使用的情况，此时定义这个变量的“位置”就不能在方法里面了，而应该在方法外面，即从（方法的）局部变量变为（类的）成员变量。那么按照主流编程语言的规定，类的成员变量不能再分配到线程的栈内存中，而应该分配到公共的堆内存中。

要让公共区域（堆内存）中的数据对于每个线程都是安全的，那就每个线程都拷贝它一份，每个线程只处理自己的这一份拷贝而不去影响别的线程的。

需要说明的是这 N 份数据都还是存储在公共区域（堆内存）里的，经常听到的“线程本地”，是从逻辑从属关系上来讲的，这些数据和线程一一对应，仿佛成了线程自己“领地”的东西了。

### 只能看，不能摸（final）

只能读取，不能修改。其实就是常量或只读变量，它们对于多线程是安全的，想改也改不了。

### 先入为主（互斥锁）

如果公共区域（堆内存）的数据要被多个线程操作时，为了确保数据的安全（或一致）性，需要在数据旁边放一把锁，要想操作数据，先获取锁再说吧。

### 相信世界充满爱，即使被伤害（乐观锁）

锁的获取和释放是要花费一定代价的，如果在线程数目特别少的时候，可能根本就不会有别的线程来操作数据。针对这种“地广人稀”的情况，专门提出了一种方法，叫 CAS（Compare And Swap）。

把之前保存的数据状态拿出来和现在的数据状态比较一下，如果一样，说明数据没有被动过（当然也有可能是先被改成了其他，然后又改回来了，这就是 ABA 问题了），那就接着继续干。如果不一样，说明数据已经被修改了，就干脆放弃，重新开始处理一遍。

对于 ABA 问题，再加一个版本号字段就行了，并规定只要修改数据，必须使版本号加 1。